---
layout: post
title:  NUCLEO-F302R8 AD変換
date:   2023-11-26 10:00:00 +0900
categories: NUCLEO-F302R8
tags: stm32 arm adc
---

前回、とりあえずモータを回転させるプログラムを作成しました。

今回はモータから発生する誘導起電圧から回転数を検出するプログラムを追加します。

誘導起電圧を検出する回路がついており、その出力がマイコンのポートに繋がっています。

ポートのAD変換の設定を行うことで、モータから発生する誘導起電圧が検出できます。

## リファレンス

マイコンのRM(リファレンスマニュアル)、DS(データシート)とPM(プログラミングマニュアル)を参照します。

RM: <https://www.st.com/resource/en/reference_manual/rm0365-stm32f302xbcde-and-stm32f302x68-advanced-armbased-32bit-mcus-stmicroelectronics.pdf>

DS: <https://www.st.com/resource/en/datasheet/stm32f302r6.pdf>

PM: <https://www.st.com/resource/ja/programming_manual/pm0214-stm32-cortexm4-mcus-and-mpus-programming-manual-stmicroelectronics.pdf>

## HW構成

* ADC1
  * ADC_IN1～ADC_IN14: チャネルが14個
* ADC2
  * F302R8はADC1のみ

### ポート

* BEMF 誘導起電圧
  * モータドライバの仕様書ではBEMF(Back ElectroMotive Force)と記載されています。
    * BEMF1: PC3 ADC1_IN9: U相の誘導起電圧
    * BEMF2: PB0 ADC1_IN11: V相の誘導起電圧
    * BEMF3: PA7 ADC1_IN15: W相の誘導起電圧
    * ポートとAD変換チャネルの対応はDS: Table 13. STM32F302x6/8 pin definitionsを参照
* 相電流
  * 今回は使用していませんが、モータの相電流を検出する回路も付いています。メモとして記載しておきます。
    * PhA: PA0: U相の電流
    * PhB: PC1: V相の電流
    * PhC: PC0: W相の電流

## AD変換の手順

1. 初期化
   1. ADCクロックの有効化
   1. GPIOをADCモードに設定
   1. 電圧レギュレータ(ADVREGEN)の有効化
   1. チャネルのモード設定
   1. キャリブレーション
   1. ADCの有効化
1. 変換処理
   1. サンプリング時間と分解能の設定
   1. 変換シーケンスの設定
   1. AD変換モードの設定
   1. AD変換開始/終了
   1. AD変換結果読み出し

## SW構成

![SW構成](/assets/images/image-2023-10-29-motor-sw-structure.png)

* ADC Task
  * aaa

## 初期化

### ADCクロックの有効化

ADCとAD変換ポートとして使用するGPIOのクロックを有効にします。

ADCのクロックはデュアルクロックドメインアーキテクチャとなっており、二つのクロックを入力して使用することができます。

1. AHBとの通信で使用するクロック。AHBバスと同じクロックになる。
1. AD変換の機能で使用するクロック。以下のどちらかを設定できる。
    1. Asynchronous clock mode: AHBバスと異なるクロック
    1. Synchronous clock mode: AHBバスと同じクロック

* RCC_AHBENR
  * ADC12EN: 1: ADC1 and ADC2 clock enabled
    * ADCがAHBとの通信で使用するクロックを有効。
  * GPIOA: 1b: I/O port A clock enabled
  * GPIOB: 1b: I/O port B clock enabled
  * GPIOC: 1b: I/O port C clock enabled
    * AD変換ポートとして使用するGPIOA,B,Cのクロックを有効

さらに、ADCの機能で使用するクロックを設定します。今回はAHBバスと同じクロックを使用します。

* ADCx_CCR
  * CKMODE: 02b: HCLK/2 (Synchronous clock mode)
    * AHBと同じクロックであるHCLKを2分周したクロックを使用します。
    * 01b: HCLK/1は今の設定では使用できません。HPRE(AHB prescaler)を0b: 分周なしで使用しているからです。RMのCKMODEの説明から、Synchronous clock modeではSYSCLK(システムクロック)の半分以下の周波数に下げる必要がありそうです。
  * CKMODE: 02b: CK_ADCx (Asynchronous clock mode)で使用するときの分周を設定するレジスタがRCC_CFGR2です。今回は使いません。メモです。

> RM: 9.2.8 ADC clock  
> RM: 15.3.3 Clocks

### GPIOをADCモードに設定

AD変換するBEMFを入力するGPIOを設定します。

* GPIOx_MODER
  * GPIOC_MODER3: 11b: Analog mode
    * BEMF1で使用するポートをAnalog modeに設定します。
  * GPIOB_MODER0: 11b: Analog mode
    * BEMF2で使用するポートをAnalog modeに設定します。
  * GPIOA_MODER7: 11b: Analog mode
    * BEMF3で使用するポートをAnalog modeに設定します。

### 電圧レギュレータ(ADVREGEN)の有効化

電圧レギュレータを有効にします。

* ADCx_CR
  * ADVREGEN
    * 10b: ADC Voltage regulator disabled
      * 電圧レギュレータが無効の状態です。
      * リセット時もこの状態です。
    * 00b: Intermediate state
      * 有効/無効を切り替える場合は一度この状態にします。
    * 01b: ADC Voltage regulator enabled
      * 電圧レギュレータが有効の状態です。
      * ただし、有効化してすぐに電圧レギュレータは動作できず、TADCVREG_STUP(約10us)待つ必要があります。

> RM: 15.3.6 ADC voltage regulator (ADVREGEN)

### チャネルのモード設定

以下の二つのモードがあります。今回はシングルエンドモードに設定します。

* シングルエンドモード
  * 入力電圧(ADC_INi)とV-refの差が変換される。iはチャネル番号。
  * 単純にAD変換したい場合はこのモード。
* ディファレンシャルモード
  * 入力電圧(ADC_INi)と入力電圧(ADC_INi+1)の差が変換される。
  * 差動電圧を変換したい場合はこのモード。

* ADCx_DIFSEL
  * DIFSEL: all 0b: single ended mode
    * 全てのチャネルをシングルエンドモードに設定します。

> 15.3.7 Single-ended and differential input channels

### キャリブレーション

リセット時にマイコン内の部品による誤差を補正するためにキャリブレーションを行います。キャリブレーションが完了するまでADCを有効にできません。

前項のシングルエンドとディファレンシャルでキャリブレーションが異なります。キャリブレーション前にADCALDIFでどちらのキャリブレーションを行うか設定します。

* ADCx_CR
  * ADCALDIF: 0b: Writing ADCAL will launch a calibration in Single-ended inputs Mode.
    * キャリブレーションをシングルエンドモードで行います。

ADCALに1を書き込むとキャリブレーションが開始します。ただし、ADCが無効の状態(ADEN=0)でキャリブレーションを開始しないといけません。

ADCALが0になるとキャリブレーションが完了です。

* ADCx_CR
  * ADCAL: 1b: Write 1 to calibrate the ADC. Read at 1 means that a calibration in progress
    * キャリブレーション中です。
  * ADCAL: 0b: Calibration complete
    * キャリブレーション完了です。

キャリブレ－ションされたデータは以下のレジスタに保存されます。これをNVMに保存して、次のリセットからはNVMに保存したデータを以下のレジスタに書き込むことでキャリブレーションすることが可能です。

* ADCx_CALFACT
  * CALFACT_S: Calibration Factors In Single-Ended mode
  * CALFACT_D: Calibration Factors in differential mode

> 15.3.8 Calibration (ADCAL, ADCALDIF, ADCx_CALFACT)

### ADCの有効化

ADCを有効にすることでAD変換ができるようになります。

ADENに1を設定するとADCの有効化がスタートします。ADRDYが1になるとADCの有効化が完了して、AD変換ができる状態になります。

* ADCx_CR
  * ADEN: Write 1 to enable the ADC.
    * 1をセットすると、ADCが有効になります。
* ADCx_ISR
  * ADRDY
    * ADRDYが1になるとAD変換の準備が完了となります。ADRDYはソフトウェアで0に戻す必要があります。ADRDYが1になるまで待ち、1になったらADRDYを0にセットします。

> 15.3.9 ADC on-off control (ADEN, ADDIS, ADRDY)

## 変換処理

これ以降はADCが有効になってから行う必要があります。

> RM: 15.3.10 Constraints when writing the ADC control bits

AD変換開始までの設定はスキップ可能です。

### サンプリング時間と分解能の設定

AD変換のサンプリング時間と分解能を設定します。

今回はデフォルトの設定で使用します。

サンプリング時間 Tsmpl: 1.5 ADC clock cycles

分解能: 12bit

量子化時間(12bit) Tsar: 12.5 ADC clock cycles

AD変換の時間: (Tsmpl + Tsar) = 14 ADC clock cycles

> RM: 15.3.16 Timing

* ADCx_SMPR1
  * SMP: 000b: 1.5 ADC clock cycles
    * デフォルトの設定です。今後調整するかもしれません。
* ADCx_CFGR
  * RES: 00b: 12-bit
    * デフォルトの設定です。今後調整するかもしれません。

> ・サンプリング時間と外部入力インピーダンス
> 外部入力インピーダンスが高いとサンプリング時間を長くする必要があります。外部入力インピーダンスはAD変換される電圧を出力する回路の出力インピーダンスです。
> DS: Table 67. Maximum ADC RAIN
> RM: 15.3.12 Channel-wise programmable sampling time (SMPR1, SMPR2)
> ・分解能
> 分解能を下げることでAD変換の時間を短くすることができます。
> RM: 15.3.22 Programmable resolution (RES) - fast conversion mode

### 変換シーケンスの設定

AD変換を行うチャネルを選択してシーケンスを作成します。

AD変換を実行すると、シーケンス内のチャネルが順番にAD変換されます。

* ADCx_SQR1
  * L(Regular channel sequence length): 0000: 1 conversion
    * シーケンスで変換するチャネルの数を設定します。AD変換1回につき1チャネルだけ変換します。
  * SQ1: チャネル番号(0x09: IN9 or 0x0B: IN11 or 0x0F: IN15)
    * シーケンスの1番目で変換するチャネルを設定します。AD変換毎にチャネルを設定します。
    * 定義外のチャネル番号(1～18以外、0も定義外)を使用しないように。

### AD変換モードの設定

AD変換のモードが2種類あり、選択できます。

* Single conversion mode
  * 1つのAD変換のトリガで1度だけAD変換を行います。
  * 必要な時だけAD変換を行うので、Continuous conversion modeより消費電力が小さいです。
* Continuous conversion mode
  * 1つのAD変換のトリガでAD変換を継続して行います。
  * 常にAD変換を行うので、Single conversion modeより消費電力を大きくなります。

今回はSingle conversion modeにします。

* ADCx_CFGR
  * CONT: 0b: Single conversion mode
    * デフォルトのままで使用します。

> RM: 15.3.13 Single conversion mode (CONT=0)
> RM: 15.3.14 Continuous conversion mode (CONT=1)

### AD変換開始/終了

AD変換を開始するときはADSTARTに1を設定します。

全てのチャネルのAD変換が完了するとADSTARTが0になります。逆に言えば、ADSTARTが1の場合は何れかのチャネルがAD変換中です。

ただし、Continuous conversion modeの場合は自動でADSTARTが0になりません。ADSTPを設定してAD変換を止めます。

* ADCx_CR
  * ADSTART
    * 0b: No ADC regular conversion is ongoing
    * 1b: ADC regular conversion is ongoing
  * ADSTP
    * 0b: No ADC stop regular conversion command ongoing
    * 1b: ADC stop regular conversion command ongoing
    * 特に使用しないです。メモです。

AD変換の結果はADCx_DRに格納されます。このレジスタはADCに一つで、各チャネルで共有します。つまり、次のAD変換が完了するまでにAD変換結果を読み出す必要があります。

* ADCx_DR

チャネルのAD変換が完了するとEOCが1になります。0クリアはソフトで行います。

EOCが1になったことを確認する方法には二つの案があります。

一つはEOCは割込みを使用します。EOCの割込みはEOCが1になったら発生します。割込みでAD変換結果の読み出しとEOCのクリアを行います。

もう一つはEOCが1になるまでループして待ちます。ビジーループになりますが、AD変換は数10μsで完了するので、許容できるなら実装が簡単な方法です。

* EOC

> RM: 15.3.15 Starting conversions (ADSTART, JADSTART)

#### 1. GPIOx

GPIOの設定を行うレジスタです。

ホールセンサで使用するGPIOを入力モードに設定します。

* GPIOx_MODER
  * GPIOA_MODER15: Input mode 00b
  * GPIOB_MODER03: Input mode 00b
  * GPIOB_MODER10: Input mode 00b
    * 上からH1,H2,H3の入力に使用します。

#### 1. EXIT

外部割込みの設定を行うレジスタです。

ホールセンサ入力の割り込みの設定を行います。

* EXIT_IMR1
  * MR15: Interrupt request from Line x is not masked 1b
  * MR3 : Interrupt request from Line x is not masked 1b
  * MR10: Interrupt request from Line x is not masked 1b
    * 上からH1,H2,H3の割込み要求のマスクを無効にします。つまり、割込み要求がNVICに通知されます。
    * EMR(Event mask register)との違いについて調べたので記載します。
      * イベントで割込みハンドラは実行されません。
      * イベントは周辺機能間で使用されます。例えば、あるGPIOにHighの信号が入力されたときにADCのサンプリングタイミングとしてイベントを通知できます。
* EXTI_RTSR1
  * TR15: Rising trigger enabled  1b
  * TR3 : Rising trigger enabled  1b
  * TR10: Rising trigger enabled 1b
    * 上からH1,H2,H3のLow⇒Highのエッジによる割込みを有効にします。
* EXTI_FTSR1
  * TR15: Falling trigger enabled  1b
  * TR3 : Falling trigger enabled  1b
  * TR10: Falling trigger enabled 1b
    * 上からH1,H2,H3のHigh⇒Lowのエッジによる割込みを有効にします。

#### 1. NVIC

割込みを有効にするレジスタです。Arm CortexM4で定義されたレジスタです。

NVIC_ISER0～NVIC_ISER2まであり、各ビットがRM: Table 41. STM32F302x6/8 vector tableのPostiionに対応します。

* NVIC_ISERx
  * ISER1_SETENA[8]: EXTI15_10 interrupt enable 1b
    * H1(EXTI15),H3(EXTI10)の割り込みを有効にします。複数の割込み要因に対して1つのハンドラが実行されるので、EXTI_PR1を確認してどちらの割込みであるかを確認する必要があります。
  * ISER0_SETENA[9]: EXTI3 interrupt enable 1b
    * H2(EXTI3)の割り込みを有効にします。こちらは割込み要因とハンドラが1対1なので、EXTI_PR1の確認は必要ないです。

### 2. イネーブル信号

#### 2. Clock

イネーブル信号で使用するGPIOのクロックを有効にします。

* RCC_AHBENR: IOPCEN Enable 1b
  * イネーブルでPC11,12,13を使用するので、GPIOCのクロックを有効にします。

#### 2. GPIOC

出力ポートの設定を行います。今回は起動時にイネーブル信号をHighにしてPWM出力を有効にするだけなので、MODERの設定だけです。高速にイネーブル信号を制御する場合はOSPEEDRの設定も必要になると思います。

* GPIOx_MODER
  * MODER22: Output mode 01b
  * MODER24: Output mode 01b
  * MODER26: Output mode 01b

### 3. PWM

PWMはマイコンのタイマーモジュールを使用します。

STM32F302x6/8で使用できるタイマーモジュールはTIM1,TIM2,TIM15,TIM16,TIM17があります。TIM1が一番高機能です。それ以外は汎用タイマとなっています。※TIM2とTIM15,TIM16,TIM17でも機能に差がありそうですが、今回は使用していないので調べていません。

今回はTIM1を使用しますので、TIM1に関するレジスタを設定します。

### 3. 構成図

![PWMの構成](/assets/images/image-2023-10-29-motor-pwm-structure.png)

> RM: Figure 132. Advanced-control timer block diagram。

* CNT
  * カウンタです。0始まりです。
  * カウントする周期を設定できます。
  * カウント方法(Up/Down/ARRで折り返し)を設定できます。
* ARR(Auto-reload register)
  * カウンタの1周期の値です。
  * カウント方法により動作が変わります。
    * UpカウントのときはCNTが0からインクリメントされ、CNTがARRを超える場合はCNTが0に戻る。
    * DownカウントのときはCNTがARRからデクリメントされ、CNTが0未満になる場合はCNTがARRに戻る。
    * ARRで折り返すときはUpカウントでCNTが0からインクリメントされ、CNTがARRを超える場合はDownカウントとなりCNTがデクリメントされる。そして、CNTが0未満になる場合はUpカウントになりCNTがインクリメントされる。
* OC
  * High/Lowを出力するコントローラです。
  * 使っていませんが、相補出力もできます。
  * GPIOのポートから出力されます。GPIOの設定が必要です。
* CCR(Capture/Compare register)
  * 出力をHigh/Lowに切り替える閾値です。
  * カウント方法に応じたCCRとCNTが一致したときの動作パターン※何れもHigh/Lowの極性は変えられます。
    * Upカウントのとき、CCR未満はHigh、CCR以上はLowを出力する。
    * Downカウントのとき、CCR以上はHigh、CCR未満はLowを出力する。
    * ARRで折り返すとき、CCR未満はHigh、CCR以上はLowを出力する。Upカウントとの違いは出力が凹になる。
* GC5C1～3
  * OCXとOC5の論理積を出力することができます。
  * 今回はOC1～3に同じPWM設定を行い、OC5を常にLow出力として、GC5CXを切り替えてなんちゃって三相のパルスを出力します。次のタイミングチャートを見てください。

### 3. タイミングチャート

![PWMのタイミングチャート](/assets/images/image-2023-10-29-motor-pwm-timingchart.png)

#### 3. Clock

TIM1のクロックを有効にします。また、TIM1から出力するPWMはGPIOを使用しますので、PWMで使用するGPIOのクロックも有効にします。

* RCC_AHBENR: IOPAEN Enable 1b
  * TIM1でPA8,9,10を使用するので、GPIOAのクロックを有効にします。
* RCC_APB2ENR: TIM1EN Enable 1b
  * TIM1のクロックを有効にします。
* RCC_CFGR3: TIM1SW PCLK 00b
  * TIM1のクロックを選択できます。デフォルトのPCLK(Peripherals Clock)を使用します。
  * CK_INTになります。

#### 3. GPIOA

* GPIOx_MODER
  * MODER8: Alternate function mode 10b
  * MODER9: Alternate function mode 10b
  * MODER10: Alternate function mode 10b
    * AFで使用します。
* GPIOx_AFRH
  * AFR8: AF6 TIM1_CH1 0110b
  * AFR9: AF6 TIM1_CH2 0110b
  * AFR10: AF6 TIM1_CH3 0110b
    * PWMで使用します。

> AFは以下のリファレンスを参照してください。
> DS: Table 14. Alternate functions for Port A

#### 3. TIM1の基本設定

制御中は基本的に変えない設定を記載します。

* TIM1_CR1
  * CKD: CK_INT 00b
    * 分周の設定です。CK_INTの周波数をそのまま使用します。
  * ARPE: TIMx_ARR register is buffered 1b
    * カウンタの自動設定を有効/無効を設定します。
  * CMS: Center-aligned mode. Interrupt flags is set when the counter is counting down 01b
    * PWMのモードを設定します。
    * RM: Figure 167. Center-aligned PWM waveformsn に具体的な波形が描かれています。
  * DIR: Counter used as upcounter 0b
    * カウント方法(カウンタアップ/カウントダウン)を選びます。
  * OPM: Counter is not stopped at update event 0b
    * Oneパルスの有効/無効を設定します。有効(1b)の場合はカウンタ満了すると特定のレジスタ(CEN)をクリアするまでカウンタがストップします。
  * CEN: Counter enabled 1b
    * カウンタが有効/無効を設定します。
* TIM1_DIER
  * CC1IE: CC1(カウンタチャネル1) interrupt enable 1b
    * チャネル1の割り込みを有効にします。割込みでTIM1_CCR5のGC5C1,GC5C2,GC5C3の切り替えを行います。
    * 割込みが発生するタイミングは RM: Figure 167. を参照してください。CMS=01なので、ダウンカウントでカウンタがCCRxと一致したときに割込みが発生します。
    * 以下の設定も忘れないように。
      * Vector Tableにハンドラを登録。RM: Table 41. STM32F302x6/8 vector tableを参照。
      * NVICの割り込みを有効にする。
* TIM1_CCMR1
  * CC1S: CC1 channel is configured as output 00b
  * CC2S: CC2 channel is configured as output 00b
    * 入力/出力を選択します。
    * RMを見るとTIM1_CCMR1のセクションが二つに分かれています。一つ目のセクションがここで入力を設定した場合のレジスタの仕様で、2つ目のセクションがここで出力を設定した場合のレジスタの仕様です。
  * OC1M: CC1 PWM mode 1  0110b
  * OC2M: CC2 PWM mode 1  0110b
    * 出力モードを選択します。PWM mode1は設定したTIMx_CCR1(カウンタ比較値)未満の時にHigh、それ以外はLowとなるPWMです。
  * OC1PE: CC1 preload enable 1b
  * OC2PE: CC2 preload enable 1b
    * プリロードの有効/無効を設定します。プリロードが有効の場合、TIMx_CCR1に書き込んだ値はプリロードレジスタに書き込まれ、カウンタが1周したときにTIMx_CCR1へ書き込まれます。
* TIM1_CCMR2
  * CC3S: CC3 channel is configured as output 00b
  * OC3M: CC3 PWM mode 1  0110b
  * OC3PE: CC3 preload enable 1b
    * CC3の設定です。CC1-2と同じです。
* TIM1_CCMR3
  * OC5M: CC3 PWM mode 1  0110b
  * OC5PE: CC3 preload enable 1b
    * CC5の設定です。CC5は出力のみです。
    * CC5はCC5とCC1,2,3に対して論理積(AND)を行うことができます。詳細はRM: 20.3.14 Combined 3-phase PWM modeを参照してください。これを使用して3相のPWMを作ります。

##### 3. NVIC 割込みコントローラ

NVICはArm Cortex-M4の機能になります。レジスタの内容はリファレンスはPMになります。

ただ、ベクターテーブルはRMを参照します。

TIM1の割り込みを有効にします。

* NVIC_ISERx
  * 割込みを有効にするレジスタです。NVIC_ISER0～NVIC_ISER2まであり、各ビットがRM: Table 41. STM32F302x6/8 vector tableのPostiionに対応します。
  * ISER1_SETENA[27]: interrupt enable 1b
    * TIM1_CCを有効にします。
    * ベクターテーブルからTIM1_CCがPosition 27となっているので、それに対応するNVIC_ISER0のbit27を1bに設定します。

##### 3. TIM1 PWMのパルス幅とDuty

制御中に変更するレジスタです。

* TIM1_PSC
  * PSC: 8
    * CNTのプリスケーラを設定します。CK_INTの8MHzを1MHzにします。つまり、1カウント=1usです。
    * 今回は制御中に変更しないです。
* TIM1_ARR
  * ARR: 23750
    * CNTの最大値です。つまり、PWMの周期になります。
    * CMSをCenter-aligned modeに設定しているので、CNTは0, 1, ..., ARR - 1, ARR, ARR - 1, ..., 1, 0とカウントされます。
    * 初期値は低速時の値を設定しています。
* TIM1_CCR1~TIM1_CCR3
  * CCR: 0
    * カウンタの閾値を設定します。閾値と一致すると、パルスの出力が反転させます。
    * CMSをCenter-aligned modeに設定しているので、閾値は2回一致します。最初に一致でHigh⇒Lowになり、次の一致(折り返し中)でLow⇒Highになります。
    * Duty = ARR / 2 = 50% にしています。
    * 初期値は0にして、常にLow出力にします。つまり、モータは停止です。
* TIM1_CCR5
  * CCR: 0
    * CC1～CC3をマスクするPWMです。CCRを0にすると、常にLow出力になります。

##### 3. 出力の有効化

出力を有効にします。複数のレジスタの組み合わせで出力が有効になります。RD: Table 116. を参照してください。

* TIM1_CCER
  * CC1E: CC1 output enable 1b
  * CC2E: CC2 output enable 1b
  * CC3E: CC3 output enable 1b
* TIM1_BDTR
  * モーターに安全機能を付けたいときに重要になるレジスタです。
  * MOE: : OC and OCN outputs are enabled 1b
    * TIM1の全体の出力を有効/無効化する設定です。
    * break信号が入力されると自動で0bとなり、出力が無効になります。
    * 出力が有効の場合はPWMが出力されます。
    * 出力が無効の場合はHi-Zとなります。無効時の出力をLow/Highで固定したい場合はOSSIを設定します。

## 割込みハンドラ

### 関数の宣言

割込みハンドラは関数の宣言で以下のように__attribute__((interrupt("IRQ")))を付けて宣言します。

``` c
/* TIM1の割込み */
void IRQ_TIM1_CC_Handler() __attribute__((interrupt("IRQ")));
void IRQ_TIM1_CC_Handler() { /* 処理 */ }
```

これにより、コンパイラが割込みハンドラ用の開始/終了処理を追加します。

__attribute__((interrupt("IRQ")))を付けない場合と比べて、スタックに退避するレジスタが多くなります。

``` asm
00000090 <IRQ_TIM1_CC_Handler>:
  /* レジスタをスタックにpush */
  90:   4668            mov     r0, sp
  92:   f020 0107       bic.w   r1, r0, #7
  96:   468d            mov     sp, r1
  98:   b481            push    {r0, r7}
  9a:   af00            add     r7, sp, #0
  /* 処理 */
  9c:   bf00            nop
  /* スタックからレジスタをpopしてリターン */
  9e:   46bd            mov     sp, r7
  a0:   bc81            pop     {r0, r7}
  a4:   4770            bx      lr
```

### Vector Tableへ登録

割込みハンドラをVector Tableに登録します。割込みハンドラを登録しないと割込みが発生したときにリセットがかかります。

コードでVector Tableをg_pfnVectorsと定義しています。コードを見てください。

### 割込み要求フラグのクリア

割込みハンドラで割込み要求フラグをクリアします。クリアしないと割込みが発生し続けます。

### ホールセンサー

ホールセンサーで使用する割込みハンドラは以下になります。ホールセンサー信号の立上り、立下りで割り込みが発生して、割込みハンドラが実行されます。

* IRQ_EXTI3_Handler
  * EXTI3専用。
* IRQ_EXTI15_10_Handler
  * EXTI10~EXTI15で共用。EXTI11などの割込みも使用する場合は次の割込み要求フラグを確認して処理を分岐させる必要がある。

割込みハンドラでは以下の割り込み要求フラグをクリアします。クリアしないと割込みハンドラが実行され続けます。他の割込みハンドラも同じです。

割込み要求フラグのレジスタは以下になります。

* EXTI_PR1
  * PR15: Triger request occured 1b
  * PR3 : Triger request occured 1b
  * PR10: Triger request occured 1b
    * 割込み要求があれば1bがセットされます。
    * 割込みハンドラが共用の場合はフラグを見て割込みを識別します。
      * 同時に複数の割込み要求がセットされる場合もあります。その場合は1回の割込みハンドラの実行で全ての割込み要求を処理するか、1回の割込みハンドラの実行で1つの割込み要求を処理するかを検討する必要があります。

今回は割込みハンドラが実行されることだけ確認し、処理は行っていません。今後、ホールセンサーの割込みでモータの回転速度の測定、回転位置の検出で使用します。

### PWM制御

PWMで使用する割込みハンドラは以下になります。

* IRQ_TIM1_CC_Handler
  * CNTがDownカウント時にCCRと一致したときに割込みが発生します。
  * このハンドラもIRQ_EXTI15_10_Handlerと同じようにCCRXで共用なので、次の割込み要求フラグを確認する必要があります。ただ、今回はCCR1の割込みだけ有効にしているので、CCR1専用として処理します。

割り込み要求フラグのレジスタは以下になります。

* TIM1_SR
  * CC1IF: Triger request occured 1b
    * カウンタのイベント発生時に割り込みが発生し、UIFがセットされます。

割込みハンドラで3. タイミングチャートのようにGC5Cを設定します。

* TIM1_CCR5
  * GC5C1
  * GC5C2
  * GC5C3

## コード

<https://github.com/ohmusso/NUCLEO-F302R8/tree/mortor>

## 動作確認

* 低速時に回転しなかったです。
* 高速時は回転しました。

<video controls width="100%" preload loop muted="true" src="/assets/movies/movie-2023-10-29-motor.mp4" type="video/mp4" >
 Sorry, your browser doesn't support embedded videos.
</video>

## 今後

* センサを使って回転数を検出できるようにします。
* PWMの制御を改善していきます。

## 以上
